#!/usr/bin/env pinpoint
[duration=40] [black] [shading-opacity=1.0] [transition=fade-fast]


# intro 3 min - Robert TODO
# architecture overview 2 - Neil
# demo 2
# libwayland-server 0.5 - Robert TODO
# interfaces, events, requests (In XML terms) 3min TODO
# global objects 3min - Neil
# rendering architecture 4min - Robert TODO
# frame callbacks 2min - Robert TODO
# gbm, kms, tty = 5min - Neil
# xwayland 4.5min - Robert TODO
# gnome shell 4min - Neil
# todo 2min - Robert TODO


#
# New outline
# -----------
#
#
# Keep the new intro 3 min
#
# Keep the architecture overview 2min
#   - (In X terms) The window manager and compositor have been moved into the
#     display server so we have one process that handles input devices, owns the
#     display hardware and is responsible for managing the client window surfaces
#     and compositing the screen.
#   - Instead of a remote rendering protocol, clients use EGL and OpenGL to
#     directly render into buffers that are passed to the compositor
#   - clients in their own world, can't discover other surface or capture
#     the events of other clients. All input events are surface relative too
#     so clients don't have to know their absolute position on screen.
#
# Keep the demo 2min
#
# libwayland-server 1min
# - utils for a handling the protocol in the compositor without graphics stuff
# 
#
# Compositors 6min
# - Interfaces, Events & Requests
#
# - Overview of XML
#
# XXX Robert XXX
# - TODO: Create a diagram
#
#
# Display      ---> Object Discovery --->   
#
# Compositor   ---> Create Surfaces --->
#	|
#	 \__ Surfaces
#	        |
#	        \__  Buffers
#	        |
#	        \__  Shell Surface
# 
# Seat	       ---> Logically group/advertise input devices --->
#
# Outputs      ---> Display Hardware --->
#
# Data Device Manager  ---> Data Devices for C & P --->
#
# Shm Object
#
# Screensaver Obj
#
#----------------
# EGL (Private)
# 
# wl_drm
#
#
#
# XXX Robert XXX
# Rendering architecture 5min
#
# TODO: Create a diagram to explain the surface creation through 
# to buffer attach process.
#
# Compositor::create_surface
#					EGL: create surface (Explain this creates a buffer)
#					Render Frame
#					SwapBuffers
#					  \__ EGL (Private)
#				  <---------- attach
# Create EGL Image
# Create GL Texture
# Render


# Explain Frame callbacks and why they are important for synchronizing the clients
# with the compositor
#
# XXX Robert XXX 2min
#
# TODO: Create a diagram to explain the surface creation through
# to buffer attach process.
#
# Compositor::create_surface
#					EGL: create surface (Explain this creates a buffer)
#					Render Frame
#				        XXX Surface::"frame" (request event from compositor when finished with buffer)
#					SwapBuffers
#					  \__ EGL (Private)
#				  <---------- attach
# Create EGL Image
# Create GL Texture
# Render
# Frame Callback -----------> XXX


# 5min
# GBM + KMS + TTY
# ===============
#
# GBM = low level API to alloc DRM buffers, that can be rendered too & directly scanned out from by the display hardware.
#
# KMS = kernel interface for controlling the display hardware
# - Mention Cogl's KMS backend (2sec MAX!)
#
# Diagram:
#   - Works in terms of CRTC's, Encoders, Connectors
#   - Explain how data flows from framebuffer through CRTC -> encoder -> connector
# 
# TTY
#   - You need to put the tty in graphics mode, block input and handle switching signals
#
#
# XWayland 5min
#   Intro
#	- Headless X server
#	- Wayland client
#	- Supports DRI2
#	- Mirrors its XRandR state based on wayland Outputs
#	- Creates a wayland surface for every top level X window
#
#
# Gnome Shell 5min
# - We implemented all the stuff we said you have to implement! (Code mostly lives in mutter/wayland/meta-wayland.c) 0.5
# - Start X wayland early on so that mutter can connect immediately as the window manager 1.5min
# - Avoid all use of the Clutter X11 API (E.g. Can't assume we can get an X window for the stage) 0.3min
# - Stacking stuff 0.2
# - Adding input support, to forward events from Clutter to X11 0.5
#	(Can use Clutter's Evdev backend)
#
#
# TODO 2min
# - Update to the latest Wayland protocols
# - Implement screen saver support
# - Implement screen shot support
# - Adapt the gnome-control-center display settings to talk directly with mutter
# - Provide a way to run gnome shell without root privileges


# General comments about what we could consider changing...
#
# The architecture diagrams:
#   - having the "Kernel" be a separate component doesn't seem quite right
#
# We don't really say anything about input handling?
# - We would need to say less about something else to be able to include this
#   though.
#
# 

-- [text-align=center] [photos/2889678711_50c3e81405_b.jpg]
Adapting Gnome Shell into a Wayland Compositor
<span color="#909090">Robert Bragg, Neil Roberts</span>

# *** ROB ***
#
# Ok, Hi everyone.
#
# The aim of this talk is to introduce you to Wayland from the compositor's
# point of view as opposed to the client side which you will hopefully already
# know something about if you were able to attend Robert Bradford's talk.
#
# My name is Robert Bragg and this is Neil Roberts and we both work in London
# as part of Intel's Open Source Technology Center. Together we develop and
# maintain the Cogl 3D graphics API used by Clutter and we've also both done a
# fair of work on Clutter itself. 
#
# Back in February of this year we both spent some time developing several
# Wayland compositors, each with an increasing level of complexity as we
# learned what was involved. We were particularly interested in being able to
# demonstrate that it was possible to adapt an existing mature X11 compositor
# into a hybrid X11 and Wayland compositor so that we could have an incremental
# path for adapting our Netbook compositor into a Wayland compositor.
#
# Thinking from a product development point of view, we had already developed a
# lot of features in our X11 based compositor and we didn't want to regress
# what we had developed to date but at the same time there are benefits to the
# Wayland architecture so we'd like to make progress in migrating from X11 to
# Wayland as soon as possible.
#
# (Just quickly, for those that don't know: Dawati Shell is a Netbook
# compositor we developed at Intel which lead to the original development of
# Mutter, based on Metacity.)
#
# We were ultimately successful in adapting our Dawati Shell into a hybrid X11
# and Wayland compositor and so it seemed only natural that we should also try
# to demonstrate that Gnome Shell could similarly be adapted into a Wayland
# compositor too, since it's also based on Mutter.
# 
# The aim of this talk is to go into some detail about what's involved in
# developing a Wayland compositor. We will try to lead through from a brief
# explanation of the overall architecture compared to X11 (This should just
# be a re-cap for those in Rob Bradfords talk), then explain a bit about the
# components you'll find inside any Wayland compositor, and explain some details
# of how the rendering architecture in particular looks inside the compositor.
# Since we don't have much time today I'm afraid we won't really say much about
# input or things such as copy and paste
#
#
# So, the aim of this talk actually isn't just to talk about what we did to
# make Gnome Shell work but instead to try and introduce, at a higher level,
# what's involved with writing any Wayland Compositor. Hopefully this
# understanding can then be applied by anyone interested in taking our work
# with Gnome Shell further but also by those that want to write their own
# compositor from scratch or contribute to some of the existing compositors out
# there such as Weston.
#
# The big proviso that you should understand here is that Wayland is still an
# evolving technology. Although we've tried to make the content of the talk
# reflect the state of Wayland in master, a lot of what we did was done back
# in February and so our code is based on Wayland 0.85 which is no longer
# compatible with the latest protocol in master.
#
# - Summary
# - Aim: wayland from compositor pov vs client side (Ref: Rob Bradford)
# - Introduce Neil and myself
# - Neil and I not working on Wayland fulltime but were back in February when
#   we developed several compositors.
# - Wanted to demonstrate it's possible to convert an existing, mature X11
#   based compositor into Wayland compositor incrementally.
# - We successfully converted our Dawati Shell Netbook compositor into a
#   hybrid compositor
# - Dawati Shell is mutter based so natually we thought we could also try
#   and demonstrate Gnome Shell as a hybrid too.
# - Clarify aim of presentation is not just about Gnome Shell
# - Proviso: rapid changes, based on 0.85
# - Maybe say something about the backgrounds
#

-- [stage-color=black] [xarch.png] [bottom-right]
The current X
architecture

# The main thing to point out here is that the X architecture requires
# us to put the compositor into a separate process.

# The compositor leaves it up to the X server to handle the display
# and pass input on to the clients.

-- [stage-color=black] [wlarch.png] [bottom-left]
The new
architecture

# The thing to point out here is that wayland combines the compositor
# into the server process.
#
# In X terminology, the window manager and compositor are now in the
# display server.
#
# There is a single process that handles input devices, owns the
# display hardware and is responsible for managing the client window
# surfaces and compositing the screen.
#
# There is no remote rendering protocol. Instead clients render
# directly into buffers using EGL and OpenGL and pass the buffers to
# the compositor.
#
# The client's are in a world of their own. All input events are
# relative to the client's surface. The client can't discover
# other surfaces or see events destined for surfaces of other clients.

--
Demo
# be SUPER careful !!!!! but also quick!!
#
# Re-iterate that we are showing gnome-shell directly controlling the display
# hardware and also directly getting input events from the evdev interface.
#
# Unfullscreen pinpoint
# load a Weston terminal
# Show stacking - could say something about this
# Show moving the terminal to a different workspace

-- [photos/1346915953_edab99dab8_b.jpg]
libwayland-server

#Explain that this lib provides just the protocol marshaling stuff +
#some utils for dealing with input grabs, data device,

#Note: there's nothing specific to the rendering architecture here

-- [photos/1346915953_edab99dab8_b.jpg]
Clients in their own world

# Explain that client surfaces all have a private coordinate space and
# its not possible to discover the surfaces of other clients like you
# can under X.
#
# This makes the compositor more free to place windows wherever it
# wants and apply whatever transformations it likes without having to
# describe those transformations to the clients

-- [photos/1346915953_edab99dab8_b.jpg]
Clients are King

# Anything that's not a shared resource is handled in the client:
# - rendering,
# - client side decorations
# - keyboard maps / interpreting keyboard events

-- [photos/3536874376_8faa3e977e_b.jpg]
How a compositor looks..
# *** ROB ***
#
# We're going to run through the basic design and components of a
# Wayland compositor...

-- [photos/3536874376_8faa3e977e_b.jpg]
Interfaces, Events &amp; Requests

# All interactions over the wayland protocol happen according to
# interfaces that are declared in XML


-- [font=Monospace 20px] [photos/3536874376_8faa3e977e_b.jpg]
&lt;<span color="#8080FF">protocol</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">xserver</span><span color="#00CD00">&quot;</span>>

  &lt;<span color="#8080FF">interface</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">xserver</span><span color="#00CD00">&quot;</span> <span color="#CDCD00">version</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">1</span><span color="#00CD00">&quot;</span>>
    &lt;<span color="#8080FF">request</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">set_window_id</span><span color="#00CD00">&quot;</span>>
      &lt;<span color="#8080FF">arg</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">surface</span><span color="#00CD00">&quot;</span> <span color="#CDCD00">type</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">object</span><span color="#00CD00">&quot;</span> <span color="#CDCD00">interface</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">wl_surface</span><span color="#00CD00">&quot;</span>/>
      &lt;<span color="#8080FF">arg</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">id</span><span color="#00CD00">&quot;</span> <span color="#CDCD00">type</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">uint</span><span color="#00CD00">&quot;</span>/>
    &lt;/<span color="#8080FF">request</span>>

    &lt;<span color="#8080FF">event</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">client</span><span color="#00CD00">&quot;</span>>
      &lt;<span color="#8080FF">arg</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">fd</span><span color="#00CD00">&quot;</span> <span color="#CDCD00">type</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">fd</span><span color="#00CD00">&quot;</span>/>
    &lt;/<span color="#8080FF">event</span>>

    &lt;<span color="#8080FF">event</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">listen_socket</span><span color="#00CD00">&quot;</span>>
      &lt;<span color="#8080FF">arg</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">fd</span><span color="#00CD00">&quot;</span> <span color="#CDCD00">type</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">fd</span><span color="#00CD00">&quot;</span>/>
    &lt;/<span color="#8080FF">event</span>>
  &lt;/<span color="#8080FF">interface</span>>

&lt;/<span color="#8080FF">protocol</span>>

# Don't worry about the details of what this particular interface is for.
#
# An interface defines a set of requests and events which can each
# have a name and a set of arguments with names and types.
#
# Requests are used for clients to ask something of the compositor.
#
# Explain that requests can't send synchronous replies, which makes
# sense for a cross process IPC protocol, but instead compositors can
# send events to send information out to clients.


-- [photos/3536874376_8faa3e977e_b.jpg]
Global objects

# Explain that interfaces are implemented by objects.
# Explain how compositors advertise objects implementing interfaces to
# clients
# - global objects that get advertised via events when a client first connects

# A wayland compositor has a collection of global objects. The global
# objects are used to handle toplevel events and requests between the
# compositor and the client.

-- [stage-color=black] [global-objects0.svg] [bottom-left]

# The main object is the Display object. A client gets a pointer to
# represent this object as soon as it connects.
#
# This works like a meta-object that the client can use to discover
# the rest of the objects.
#
# When a client connects the compositor will send it an event for each
# of the other global objects so that it bind any objects it is
# interested in.

-- [stage-color=black] [global-objects1.svg] [bottom-left]

# The Compositor object has a request to create new surfaces. The
# surfaces are like windows in the X world.

-- [stage-color=black] [global-objects10.svg] [bottom-left]

# A seat represents a collection of input devices such as a keyboard
# and mouse pair. The compositor can advertise multiple seats.
#
# The seat object will send events to clients that bind the object.

-- [stage-color=black] [global-objects20.svg] [bottom-left]

# The output object represents part of the compositor geometry. This
# is a rectangle within the compositor coordinate system. Typically
# this represents a monitor connector to the computer.
#
# The client listen for events on this object to learn about the
# monitor configurations

-- [stage-color=black] [global-objects30.svg] [bottom-left]

# As part of the rendering system, there will be a private global
# object to handle requests to create buffers.
#
# This is encapsulated under the EGL implementation used by the client
# and server.
#
# Under Mesa, this will be a wl_drm interface which has a request to
# create a wayland buffer given an allocated DRM buffer handle. This
# is how the results of rendering are passed to the compositor.

-- [photos/depot.jpg]
The rendering architecture...
# *** NEIL ***
#
#
-- [stage-color=black] [surface-create.svg] [bottom-left]
-- [stage-color=black] [surface-create0.svg] [bottom-left]
-- [stage-color=black] [surface-create10.svg] [bottom-left]
-- [stage-color=black] [surface-create20.svg] [bottom-left]
-- [stage-color=black] [surface-create30.svg] [bottom-left]
-- [stage-color=black] [surface-create40.svg] [bottom-left]
-- [stage-color=black] [surface-create50.svg] [bottom-left]
-- [stage-color=black] [surface-create60.svg] [bottom-left]
-- [stage-color=black] [surface-create70.svg] [bottom-left]
-- [stage-color=black] [surface-create80.svg] [bottom-left]
-- [stage-color=black] [surface-create90.svg] [bottom-left]
-- [stage-color=black] [surface-create100.svg] [bottom-left]

-- [stage-color=black] [sync-frame.svg] [bottom-left]


-- [photos/depot.jpg]
SHM buffers

# This is a simple mechanism for sharing buffers
#
# This client can directly render into the system-mapped memory using
# a software rendering library such as Cairo.
#
# This should probably be avoided by clients because it requires a
# copy from the shared memory to a texture in the compositor.
-- [photos/depot.jpg]
EGL

# EGL is a platform independent window system API
#
# It is used to create a GL or GLES context and bind into to a window
# or offscreen buffer.
#
# It can be considered a replacement for GLX.
-- [photos/depot.jpg]
eglCreateDisplay(NativeDisplayType display)
eglCreateWindowSurface(EGLNativeWindowType)

# These two functions are platform-independent but take a point to a
# native type. They are effectively void* pointers that the EGL
# implementation interprets how it likes.
#
# For example, to create an EGL display you have to pass it a
# NativeDisplayType. This is a platform specific pointer representing
# the display. Eg, for X it could be the X Display* pointer. It is up
# to the EGL implementation to interpret this pointer correctly.
#
# So for the second function on X we'd pass an Xlib Window.

-- [bottom] [egl-in-wayland.png]
EGL in Wayland

# Both client and compositor link to EGL.
#
# It is up to the implementation for how it passes buffers between
# client and compositor. It can define whatever internal extensions
# needed.
#
# In Mesa it will create a wl_drm global interface for the client to use.

-- [photos/depot.jpg]
EGL in Clients...

# The EGL implementation has to have specific support to interpret
# EGLNativeDisplayType and EGLNativeWindowType as wayland types.
# The client would then do the following:
-- [font=45px] [photos/depot.jpg]
eglCreateDisplay(NativeDisplayType display)

# To start we need to get a pointer to pass here.

-- [photos/depot.jpg]
<i>Create a wayland display object</i>

<tt>
<span color="#00CDCD">struct</span> <span color="#00CD00">wl_displa</span><span color="#00CD00">y</span> *<span color="#CDCD00">display</span> =
  wl_display_connect (<span color="#CD00CD">NULL</span>);
</tt>

# This returns an object representing the connection on the socket to
# the Wayland display server. This can be considered an equivalent to
# the Display* pointer in X.
-- [font=28px] [photos/depot.jpg]
<i>Bind to the wl_compositor interface</i>
<tt>
  <span color="#00CDCD">if</span> (strcmp(interface, <span color="#00CD00">&quot;wl_compositor&quot;</span>) == 0)
    d->compositor =
      wl_display_bind(display, id,
                      &amp;wl_compositor_interface);
</tt>

# The client needs a handle to represent the compositor's global
# wl_compositor interface. It can get this by handle the 'global'
# event on the wl_display interface and then binding the object as
# shown.
-- [photos/depot.jpg]
wl_compositor::create_surface

# This is a method on the compositor's wl_compositor object to create
# a surface. The client generates an ID for the surface.
-- [font=35px] [photos/depot.jpg]
eglCreateWindowSurface(EGLNativeWindowType)

# This is the EGL function to create a surface.
#
# We need to fill in a native 
# Once the client has a wl_egl_window* pointer it can pass that to
# EGL as the native window type to create a regular EGL surface.
#
# The surface can then be used with eglMakeCurrent to bind the GL context.
# From then on the application can just use regular GL or GLES.
--[font=28px] [photos/depot.jpg]
<i>libwayland-egl:</i>

<tt>
<span color="#00CDCD">struct</span> <span color="#00CD00">wl_egl_windo</span><span color="#00CD00">w</span> *
<span color="#8080FF">wl_egl_window_create</span>(<span color="#00CDCD">struct</span> <span color="#00CD00">wl_surface</span> *<span color="#CDCD00">surface</span>,
                     <span color="#00CD00">int</span> <span color="#CDCD00">width</span>,
                     <span color="#00CD00">int</span> <span color="#CDCD00">height</span>);
</tt>

# libwayland-egl is some wayland-specific functions in the EGL implementation
# This function is used to create a structure which combines a size with a
# wayland surface.
-- [photos/depot.jpg]
EGL in the Compositor

# On the compositor side the compositor can use whatever EGL platform
# it likes. For example it could use an X display and an X window as a
# surface to create a compositor that is nested under X. However the
# EGL implementation has to implement this one extension...
-- [photos/depot.jpg]
EGL_WL_bind_wayland_display
# ... this extension contains one function...
-- [font=Monospace 20px] [photos/depot.jpg]
eglBindWaylandDisplayWL()

# ... The compositor must call this to tell the EGL implementation
# that it should accept buffers passed in from clients. How this works
# is up to the implementation but in Mesa it will register a global
# object with the wl_drm interface.

-- [photos/2889657735_5234d83de4_b.jpg]
Implementing some interfaces...
# *** ROB ***
#
# Say that we'll go though some of the key interfaces involved in writing a
# compositor and give a taster of how we implement these...

-- [photos/2889657735_5234d83de4_b.jpg]
Wayland outputs

-- [font=Monospace 20px] [photos/2889657735_5234d83de4_b.jpg]
  &lt;<span color="#8080FF">interface</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">wl_output</span><span color="#00CD00">&quot;</span> <span color="#CDCD00">version</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">1</span><span color="#00CD00">&quot;</span>>
    &lt;<span color="#8080FF">enum</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">subpixel</span><span color="#00CD00">&quot;</span>> ... &lt;/<span color="#8080FF">enum</span>>
    &lt;<span color="#8080FF">event</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">geometry</span><span color="#00CD00">&quot;</span>> ... &lt;/<span color="#8080FF">event</span>>
    &lt;<span color="#8080FF">enum</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">mode</span><span color="#00CD00">&quot;</span>> ... &lt;/<span color="#8080FF">enum</span>>
    &lt;<span color="#8080FF">event</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">mode</span><span color="#00CD00">&quot;</span>> ... &lt;/<span color="#8080FF">event</span>>
  &lt;/<span color="#8080FF">interface</span>>

# Note that this interface is stripped to just give an outline of what it deals
# with

-- [photos/2889657735_5234d83de4_b.jpg]
Handling Output Binding..

-- [font=Monospace 20px] [photos/2889657735_5234d83de4_b.jpg]
<span color="#00CDCD">struct</span> <span color="#00CD00">wl_resourc</span><span color="#00CD00">e</span> *<span color="#CDCD00">resource</span> =
  wl_client_add_object (client, &amp;wl_output_interface, <span color="#CD00CD">NULL</span>, id, data);

wl_resource_post_event (resource,
			WL_OUTPUT_GEOMETRY,
			output->x, output->y,
			output->width_mm,
			output->height_mm,
			0, <span color="#CDCD00">/* </span><span color="#CDCD00">subpixel: unknown </span><span color="#CDCD00">*/</span>
			<span color="#00CD00">&quot;unknown&quot;</span>, <span color="#CDCD00">/* </span><span color="#CDCD00">make </span><span color="#CDCD00">*/</span>
			<span color="#00CD00">&quot;unknown&quot;</span>); <span color="#CDCD00">/</span><span color="#CDCD00">* </span><span color="#CDCD00">model </span><span color="#CDCD00">*/</span>

<span color="#CDCD00">wl_list_for_each</span> (mode, &amp;output->mode_list, link) {
      wl_resource_post_event(resource,
			     WL_OUTPUT_MODE,
			     mode->flags,
			     mode->width,
			     mode->height,
			     mode->refresh);
}

# Explain that this is an example of what might be done in the compositors bind
# callback function to immediately respond to a binding by sending the client
# an event describing the output's geometry.
#
# Instead of just sending "unknown" for the make and model though a compositor
# will use some other api like KMS to query more meaningful names.

-- [photos/2889657735_5234d83de4_b.jpg]
The Compositor object

-- [font=Monospace 20px] [photos/2889657735_5234d83de4_b.jpg]
  &lt;<span color="#8080FF">interface</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">wl_compositor</span><span color="#00CD00">&quot;</span> <span color="#CDCD00">version</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">1</span><span color="#00CD00">&quot;</span>>
    &lt;<span color="#8080FF">request</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">create_surface</span><span color="#00CD00">&quot;</span>>
      &lt;<span color="#8080FF">arg</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">id</span><span color="#00CD00">&quot;</span> <span color="#CDCD00">type</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">new_id</span><span color="#00CD00">&quot;</span> <span color="#CDCD00">interface</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">wl_surface</span><span color="#00CD00">&quot;</span>/>
    &lt;/<span color="#8080FF">request</span>>
  &lt;/<span color="#8080FF">interface</span>>

# Remember to note that the xml snippet is a pseudo description

# Explain that this interface is used by clients to create new surfaces
#

-- [font=Monospace 30px] [photos/2889657735_5234d83de4_b.jpg]
<span color="#00CDCD">static</span> <span color="#00CD00">voi</span><span color="#00CD00">d</span>
<span color="#8080FF">compositor_create_surface</span> (<span color="#00CDCD">struct</span> <span color="#00CD00">wl_client</span> *<span color="#CDCD00">client</span>,
                           <span color="#00CDCD">struct</span> <span color="#00CD00">wl_resource</span> *<span color="#CDCD00">compositor_resource</span>,
                           <span color="#00CD00">guint32</span> <span color="#CDCD00">id</span>)
{
  <span color="#00CD00">MyComposito</span><span color="#00CD00">r</span> *<span color="#CDCD00">compositor</span> = compositor_resource->data;
  <span color="#00CD00">MySurfac</span><span color="#00CD00">e</span> *<span color="#CDCD00">surface</span> = g_slice_new0 (MySurface);

  surface->compositor = compositor;

  surface->wl_surface.resource.destroy = my_surface_resource_destroy_cb;
  surface->wl_surface.resource.object.id = id;
  surface->wl_surface.resource.object.interface = &amp;wl_surface_interface;
  surface->wl_surface.resource.object.implementation =
          (<span color="#00CD00">void</span> (**)(<span color="#00CD00">void</span>)) &amp;my_surface_interface;
  surface->wl_surface.resource.data = surface;

  wl_client_add_resource (client, &amp;surface->wl_surface.resource);

  compositor->surfaces = g_list_prepend (compositor->surfaces, surface);
}

-- [font=Monospace 30px] [photos/2889657735_5234d83de4_b.jpg]
<span color="#00CDCD">static</span> <span color="#00CD00">voi</span><span color="#00CD00">d</span>
<span color="#8080FF">compositor_create_surface</span> (<span color="#00CDCD">struct</span> <span color="#00CD00">wl_client</span> *<span color="#CDCD00">client</span>,
                           <span color="#00CDCD">struct</span> <span color="#00CD00">wl_resource</span> *<span color="#CDCD00">compositor_resource</span>,
                           <span color="#00CD00">guint32</span> <span color="#CDCD00">id</span>)
{
  <span color="#00CD00">MyComposito</span><span color="#00CD00">r</span> *<span color="#CDCD00">compositor</span> = compositor_resource->data;
  <span background="#ff0000">MySurface *surface = g_slice_new0 (MySurface);</span>

  surface->compositor = compositor;

  surface->wl_surface.resource.destroy = my_surface_resource_destroy_cb;
  surface->wl_surface.resource.object.id = id;
  surface->wl_surface.resource.object.interface = &amp;wl_surface_interface;
  surface->wl_surface.resource.object.implementation =
          (<span color="#00CD00">void</span> (**)(<span color="#00CD00">void</span>)) &amp;my_surface_interface;
  surface->wl_surface.resource.data = surface;

  wl_client_add_resource (client, &amp;surface->wl_surface.resource);

  compositor->surfaces = g_list_prepend (compositor->surfaces, surface);
}

-- [font=Monospace 30px] [photos/2889657735_5234d83de4_b.jpg]
<span color="#00CDCD">static</span> <span color="#00CD00">voi</span><span color="#00CD00">d</span>
<span color="#8080FF">compositor_create_surface</span> (<span color="#00CDCD">struct</span> <span color="#00CD00">wl_client</span> *<span color="#CDCD00">client</span>,
                           <span color="#00CDCD">struct</span> <span color="#00CD00">wl_resource</span> *<span color="#CDCD00">compositor_resource</span>,
                           <span color="#00CD00">guint32</span> <span color="#CDCD00">id</span>)
{
  <span color="#00CD00">MyComposito</span><span color="#00CD00">r</span> *<span color="#CDCD00">compositor</span> = compositor_resource->data;
  <span color="#00CD00">MySurfac</span><span color="#00CD00">e</span> *<span color="#CDCD00">surface</span> = g_slice_new0 (MySurface);

  surface->compositor = compositor;

<span background="#ff0000">  surface->wl_surface.resource.destroy = my_surface_resource_destroy_cb;
  surface->wl_surface.resource.object.id = id;
  surface->wl_surface.resource.object.interface = &amp;wl_surface_interface;
  surface->wl_surface.resource.object.implementation =
          (void (**)(void)) &amp;my_surface_interface;
  surface->wl_surface.resource.data = surface;</span>

  wl_client_add_resource (client, &amp;surface->wl_surface.resource);

  compositor->surfaces = g_list_prepend (compositor->surfaces, surface);
}

-- [font=Monospace 30px] [photos/2889657735_5234d83de4_b.jpg]
<span color="#00CDCD">static</span> <span color="#00CD00">voi</span><span color="#00CD00">d</span>
<span color="#8080FF">compositor_create_surface</span> (<span color="#00CDCD">struct</span> <span color="#00CD00">wl_client</span> *<span color="#CDCD00">client</span>,
                           <span color="#00CDCD">struct</span> <span color="#00CD00">wl_resource</span> *<span color="#CDCD00">compositor_resource</span>,
                           <span color="#00CD00">guint32</span> <span color="#CDCD00">id</span>)
{
  <span color="#00CD00">MyComposito</span><span color="#00CD00">r</span> *<span color="#CDCD00">compositor</span> = compositor_resource->data;
  <span color="#00CD00">MySurfac</span><span color="#00CD00">e</span> *<span color="#CDCD00">surface</span> = g_slice_new0 (MySurface);

  surface->compositor = compositor;

  surface->wl_surface.resource.destroy = my_surface_resource_destroy_cb;
  surface->wl_surface.resource.object.id = id;
  surface->wl_surface.resource.object.interface = &amp;wl_surface_interface;
  surface->wl_surface.resource.object.implementation =
          (<span color="#00CD00">void</span> (**)(<span color="#00CD00">void</span>)) &amp;my_surface_interface;
  surface->wl_surface.resource.data = surface;

  <span background="#ff0000">wl_client_add_resource (client, &amp;surface->wl_surface.resource);</span>

  compositor->surfaces = g_list_prepend (compositor->surfaces, surface);
}


--  [photos/2889657735_5234d83de4_b.jpg]
The wl_surface interface

-- [font=Monospace 20px] [photos/2889657735_5234d83de4_b.jpg]
  &lt;<span color="#8080FF">interface</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">wl_surface</span><span color="#00CD00">&quot;</span> <span color="#CDCD00">version</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">1</span><span color="#00CD00">&quot;</span>>
    &lt;<span color="#8080FF">request</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">destroy</span><span color="#00CD00">&quot;</span> <span color="#CDCD00">type</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">destructor</span><span color="#00CD00">&quot;</span>/>
    &lt;<span color="#8080FF">request</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">attach</span><span color="#00CD00">&quot;</span>> ... &lt;/<span color="#8080FF">request</span>>
    &lt;<span color="#8080FF">request</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">damage</span><span color="#00CD00">&quot;</span>> ... &lt;/<span color="#8080FF">request</span>>
    &lt;<span color="#8080FF">request</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">frame</span><span color="#00CD00">&quot;</span>> ... &lt;/<span color="#8080FF">request</span>>
  &lt;/<span color="#8080FF">interface</span>>

-- [photos/depot.jpg]
Handling buffer attach requests

-- [font=Monospace 20px] [photos/2889657735_5234d83de4_b.jpg]
<i>Handling a buffer attach from a client</i>
<tt>
<span color="#00CDCD">static</span> <span color="#00CD00">voi</span><span color="#00CD00">d</span>
<span color="#8080FF">my_surface_attach_buffer</span> (<span color="#00CDCD">struct</span> <span color="#00CD00">wl_client</span> *<span color="#CDCD00">wayland_client</span>,
                          <span color="#00CDCD">struct</span> <span color="#00CD00">wl_resource</span> *<span color="#CDCD00">surface_resource</span>,
                          <span color="#00CDCD">struct</span> <span color="#00CD00">wl_resource</span> *<span color="#CDCD00">buffer_resource</span>,
                          <span color="#00CD00">gint32</span> <span color="#CDCD00">dx</span>, <span color="#00CD00">gint32</span> <span color="#CDCD00">dy</span>)
{
 <span color="#00CDCD">struct</span> <span color="#00CD00">my_surfac</span><span color="#00CD00">e</span> *<span color="#CDCD00">surface</span> = surface_resource->data;
 <span color="#00CDCD">struct</span> <span color="#00CD00">my_composito</span><span color="#00CD00">r</span> *<span color="#CDCD00">compositor</span> = surface->compositor;
 <span color="#00CDCD">struct</span> <span color="#00CD00">wl_buffe</span><span color="#00CD00">r</span> *<span color="#CDCD00">buffer</span> = buffer_resource->data;

 <span color="#00CD00">EGLImag</span><span color="#00CD00">e</span> <span color="#CDCD00">image</span> = eglCreateImageKHR (compositor->display, <span color="#CD00CD">NULL</span>,
                                     EGL_WAYLAND_BUFFER_WL,
                                     buffer, <span color="#CD00CD">NULL</span>);

 <span color="#00CD00">GLuin</span><span color="#00CD00">t</span> <span color="#CDCD00">tex</span>;
 glGenTextures (1, &amp;tex);
 glBindTexture (GL_TETURE_2D, tex);
 glEGLImageTargetTexture2DOES (GL_TEXTURE_2D, image);

 eglDestroyImageKHR (compositor->display, image);

 surface->texture = tex;
}
</tt>

# This request is made whenever the client has finished rendering a
# frame to pass the new buffer to the server. The client
# implementation of EGL will use this request whenever eglSwapBuffers
# is called.
#
# In the Cogland example we use a function from the Cogl API to
# convert the buffer to a texture.

-- [photos/2889657735_5234d83de4_b.jpg]
Frame callbacks

# With current X compositors it can be quite difficult to synchronize
# rendering clients with the redraw of the compositor.
#
# It's quite easy to end up in a situation where the client is
# rendering at a very high frame-rate and hogging the GPU. The
# compositor is then only able to render at a much lower frame-rate so
# most of the frames of the client are dropped. The client's rendering
# is therefore mostly redundant.
#
# Wayland tries to fix this problem by sending a 'frame done'
# notification to all clients whenever it has completed rendering a
# composited frame. That way clients can rate limit themselves to
# frames that will actually get displayed.
#
# XXX: Explain that clients explicitly create a frame callback object
# using the wl_surface::frame request.
#
# This can make a big power saving.

-- [photos/2889657735_5234d83de4_b.jpg] [font=25px]
<i>Post frame callback-done events on paint</i>
<tt>
  <span color="#00CDCD">while</span> (!g_queue_is_empty (&amp;compositor->frame_callbacks))
    {
      <span color="#00CD00">CoglandFrameCallbac</span><span color="#00CD00">k</span> *<span color="#CDCD00">callback</span> =
        g_queue_peek_head (&amp;compositor->frame_callbacks);

      wl_resource_post_event (&amp;callback->resource,
                              WL_CALLBACK_DONE, get_time ());
      wl_resource_destroy (&amp;callback->resource, 0);
    }
</tt>

# This code posts an event on the resource belonging to the callback
# registered for the notification.
#
# The resource is then automatically destroyed. This is part of the
# contract of the callback interface.

-- [photos/2889657735_5234d83de4_b.jpg]
The wl_shell and wl_shell_surface interface

# Just skim over the "wl_shell" interface only saying that it has a
# "get_shell_surface" request that's given a wl_surface id.

-- [font=Monospace 20px] [photos/2889657735_5234d83de4_b.jpg]
  &lt;<span color="#8080FF">interface</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">wl_shell_surface</span><span color="#00CD00">&quot;</span> <span color="#CDCD00">version</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">1</span><span color="#00CD00">&quot;</span>>
    &lt;<span color="#8080FF">request</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">move</span><span color="#00CD00">&quot;</span>> ... &lt;/<span color="#8080FF">request</span>>
    &lt;<span color="#8080FF">enum</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">resize</span><span color="#00CD00">&quot;</span>> ... &lt;/<span color="#8080FF">enum</span>>
    &lt;<span color="#8080FF">request</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">resize</span><span color="#00CD00">&quot;</span>> ... &lt;/<span color="#8080FF">request</span>>
    &lt;<span color="#8080FF">request</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">set_toplevel</span><span color="#00CD00">&quot;</span>/>
    &lt;<span color="#8080FF">request</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">set_transient</span><span color="#00CD00">&quot;</span>> ... &lt;/<span color="#8080FF">request</span>>
    &lt;<span color="#8080FF">request</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">set_fullscreen</span><span color="#00CD00">&quot;</span>/>
    &lt;<span color="#8080FF">request</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">set_popup</span><span color="#00CD00">&quot;</span>> ... &lt;/<span color="#8080FF">request</span>>
    &lt;<span color="#8080FF">event</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">configure</span><span color="#00CD00">&quot;</span>> ... &lt;/<span color="#8080FF">event</span>>
    &lt;<span color="#8080FF">event</span> <span color="#CDCD00">name</span>=<span color="#00CD00">&quot;</span><span color="#00CD00">popup_done</span><span color="#00CD00">&quot;</span>/>
  &lt;/<span color="#8080FF">interface</span>>

# Explain that the wl_shell_surface interface provides some higher level
# requests that start to relate to the varying policies of the windowing
# system. It starts to encapsulate some of the things you would see in the X
# ICCCM or EWMH standards but currently is very constrained to the essentials
# that can be applied to basically any compositing environment.
#
# It's likely that this interface will evolve as more advanced wayland
# environments get developed and it's also very likely for specialised
# environments to provide their own shell_surface like extensions to allow more
# custom surface related requests and events.

-- [photos/white-house.jpg]
Owning the display

# Mutter is no longer relying on X to handle the display so we need to
# do it ourselves.
#
# Here are the three main systems needed to make that happen.

-- [photos/white-house.jpg] [font=50px] [text-align=center]
GBM
generic / graphics buffer manager

# GBM is a low-level API to allocate DRM buffers. They can then be
# bound to EGL and rendered to using OpenGL without having to connect
# to an X display. The buffers are allocated within Mesa so it will do
# the right thing to allocate a buffer that can be directly scanned
# out from.

-- [kms.png] [top] [font=50px] [text-align=center]
KMS
Kernel Mode Setting

# KMS is "Kernel Mode Setting"
#
# It is a kernel interface used to control the display hardware.
#
# Data flows from the CRTC to the encoder to the connector.
#
# You can use the library to pick and configure the CRTC,encoder and connector.
#
# Cogl has a backend to do most of the work in setting up GBM buffers
# and handling KMS.

-- [photos/white-house.jpg]
TTY

# You need to control the TTY
#
# • Put the tty in graphics mode.
# • Listen for signals to be notified when the user switches VT to drop
#   DRM master mode and switch back to to text mode
# • You need to block input to the TTY. Otherwise everything you type
#   in the compositor will also by typed into the login screen of the
#   VT underneath.

-- [photos/bridge.jpg]
xwayland

# *** ROB ***
#
# Introduce that X wayland is a means to support legacy X clients
#
# Introduce that the compositor is responsible for starting an X
# wayland server for X clients to connect too.

-- [photos/bridge.jpg]
Starting X Wayland lazily...

# Introduce the idea of loading X wayland lazily only when we have X
# clients that require an xserver for compatibility.
# 
#

-- [photos/bridge.jpg]
Create a lock file

# This is just a case of iterating though the display number space
# looking for a free display number so we can open a free
# /tmp/.X11-lock file (checking existing lock files to see if they are
# stale) before we go ahead and open a unix domain socket.

-- [photos/bridge.jpg]
Open a unix domain socket

# Once we have found a free display number we can create a corresponding
# /tmp/.X11-unix/X? unix domain socket for X clients to connect too.
#
# We can immediately mark the socket as a passive, listening socket via
# listen(2)

-- [photos/bridge.jpg]
Poll for the socket to be readable

# Now we can poll until an x client tries to connect to the X domain socket

-- [photos/bridge.jpg]
socketpair() for wayland protocol before fork()

# Explain that we want xwayland to be a wayland client so we want to establish
# a socket connection between the compositor and xwayland.
#
# We create a socketpair() just before fork()ing to run xwayland so
# that we can give one end of the pair to xwayland. We use an
# "WAYLAND_SOCKET" environment variable to convey the file descriptor
# to xwayland.

-- [photos/bridge.jpg]
fork() xwayland

-- [photos/bridge.jpg]
Wait for "xserver" binding

# Once we know that xwayland has bound the "xserver" interface then we
# know that the server is initialized and we can also start sending
# events.

-- [photos/bridge.jpg]
Pass listen socket to xwayland

# So that xwayland can deal with actually accept()ing the new client
# connection and also handling further client connections the file
# descriptor for the unix domain socket is passed over the wayland
# protocol to xwayland.

# The file descriptor is sent using the "listen_socket" event
# described in the xserver.xml wayland protocol.

-- [font=Monospace 20px] [photos/bridge.jpg]
wl_client_flush (xwayland_client)

# A detail to be careful about is that you flush the wayland events
# passing the listen socket to xwayland to avoid a deadlock when
# trying connecting to xwayland as an X client to become the window
# manager.

-- [photos/bridge.jpg]
Connect as window manager

# At this point the compositor now becomes a window manager for xwayland
# clients.

-- [text-align=center] [photos/bridge.jpg]
Pair surfaces &amp; windows according
to "set_window_id" requests.

# Once xwayland is initialized we can now expect "create_surface"
# requests to the wl_compositor object that correspond to top level X
# windows.
#
# We can also expect "set_window_id" events over the wayland protocol
# to inform us about which X Window corresponds to a given xwayland
# surface.


-- [photos/bridge.jpg]
Caveats...

-- [photos/bridge.jpg] [font=40px]
Unsynchronized X and wayland protocols

# Beware of having separate X and wayland command streams. If a
# wayland surface for an x client is destroyed you might want to know
# if the window was just unmapped or really destroyed which is
# something you learn from the X protocol so now your in the awkward
# situation of having to match corresponding events in each stream.
#
# Perhaps at some point it could be better to proxy one protocol over the other
# so we know things are synchronized but for now at least we've found that
# consistently making sure to process X events before wayland events works OK
#FIXME more...

-- [photos/bridge.jpg] [font=40px]
Beware about forwarding mouse input

# This problem mostly just applies to porting X compositors to be
# hybrid compositor since they will expect to handle X motion events
# e.g. for moving windows. Compositors should only handle mouse events
# coming directly into the compositor (e.g. from evdev) because it's
# not reliable to feed events to xwayland and rely on them being
# reported back via X and being consistent with the current composited
# position of a window.

-- [photos/bridge.jpg]
Sync X windows position to screen

# Keep X window positions in synch with composited position if want
# you want X toolkit menus to behave correctly.
#
# xwayland synchronizes its xrandr state according the wayland
# compositor outputs and X toolkits use the xrandr state to ensure
# they don't position pop up menus offscreen or crossing over multiple
# screens.

-- [photos/bridge.jpg]
Gnome Shell

-- [photos/bridge.jpg] [text-align=center]
Gnome Shell
<span font="30px">
We've implemented most of the core things
mentioned already. Code is available on the wip/wayland
branches of Mutter and Gnome Shell</span>

# We've implemented most of the bits we've already mentioned as you saw
# in the demo.
#
# KMS is working, the necessary global objects are implemented and
# input events are forwarded

-- [photos/bridge.jpg] [text-align=center]
Gnome Shell

<span font="30px">Mutter is still an X client</span>

# Mutter and Gnome Shell are still running as X clients.
#
# Mutter still connects to the X server as the window manager and
# still does most of the window positioning via X calls. It also
# receives most of the events through X.
#
# Therefore we need to start xwayland as pretty much the first thing
# we do.

-- [photos/bridge.jpg] [text-align=center]
Gnome Shell

<span font="30px">but it's not using the Clutter X11 backend</span>

# Although Mutter is an X client, Clutter itself is not using X.
#
# Therefore Mutter can't use any Clutter X API such as getting the
# Window ID for the stage.

-- [photos/bridge.jpg] [text-align=center]
Gnome Shell

<span font="30px">Window stacking</span>

# Rob's got the window stacking between X clients and Wayland clients to work.
#
# There's some quite fiddly details here because the existing stacking
# code tries to work in terms of keeping the stacking in sync with the
# X server's representation of the stack.
#
# Of course for Wayland surfaces there is no X window.

-- [photos/bridge.jpg] [text-align=center]
Gnome Shell

<span font="30px">Input support</span>

# Input events are forwarded on to the Wayland clients
#
# This includes the xwayland client.
#
# The events are received from Clutter which gets them from evdev.
# Mutter then forwards them to the right surface.
#
# X events can them come back to Mutter. This is way too complicated
# so it would be nice to get Mutter to only use Clutter events for
# input

-- [photos/waylnad-street.jpg] [bottom]
TODO

-- [photos/5338839892_7f8d2535ed_b.jpg]
Where should you start?

-- [photos/5338839892_7f8d2535ed_b.jpg] [font=40px] [text-align=center]
<span size="large"><b>Weston</b></span>

<tt>git://anongit.freedesktop.org/wayland/weston</tt>

# The demo compositor for Wayland
#
# It's heading towards being a complete usable standalone compositor.
#
# This is kept up-to-date with all the latest Wayland protocol changes
# so it's a very useful example implementation. Much of the code for
# our Mutter hybrid compositor work borrows code from Weston.
-- [photos/5338839892_7f8d2535ed_b.jpg] [font=30px]
<span size="large"><b>Links</b></span>

Cogland
<tt>git://git.gnome.org/cogl</tt>


test-wayland-surface (the small Clutter compositor)
<tt>http://github.com/clutter-project/test-wayland-surface</tt>

Our latest work is on the ‘fosdem-2012’ branches for both

Mutter
<tt>git://git.gnome.org/mutter</tt>
on the wip/wayland branch

Mesa gbm patches
<tt>git://anongit.freedesktop.org/~rib/mesa</tt>

A QT compositor
<tt>git://gitorious.org/qt-labs/qt-compositor.git</tt>
-- [photos/5338839892_7f8d2535ed_b.jpg]
\#wayland on irc.freenode.net

-- [photos/5968108862_d5240a042b_b.jpg] [bottom] [font=80px]
DEMO

--[font=18px]
Attributions

2889678711_50c3e81405_b.jpg cc by-nc-sa tinydr
494823929_a427f05ce4_b.jpg  cc by-nc-sa rcolonna
2889678725_55f1e7fbeb_b.jpg cc by-nc-sa tinydr
2889642385_0a8c8592a6_b.jpg cc by-nc-sa tinydr
5338839892_7f8d2535ed_b.jpg cc by-nc-sa waltarrrrr
5968108862_d5240a042b_b.jpg cc by 2.0 petcoffr
2889657735_5234d83de4_b.jpg cc by-nc-sa tinydr
3536874376_8faa3e977e_b.jpg cc by-nc-sa SkyprPhotography
1346915953_edab99dab8_b.jpg cc by-nc-sa 'fake is the new real'
2988748371_a16e92f0b6_b.jpg cc by-nc-nd 2.0 Christine Myaskovsky (chrissymckeen)
basketball.jpg cc by-sa 2.0 Dougtone
first-town-center.jpg cc by-sa 2.0 Dougtone
white-house.jpg cc by-sa 2.0 Dougtone
waylnad-street.jpg cc by-nc-nd 2.0 throgers
parish.jpg cc by 3.0 John Phelan
bridge.jpg public domain Daderot
town-building.jpg public domain Daderot
river.jpg public domain Daderot
depot.jpg cc by 3.0 John Phelan
middle-shool.jpg cc by 3.0 John Phelan
wayland-kerb.jpg cc by 2.0 Marcin Wichary
